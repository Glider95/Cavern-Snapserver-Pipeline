Here is the issue that I am trying to troubleshoot.

Checklist
Stream an encoded audio track (E-AC-3) continuously into dolby-in.
Ensure PipeInputClient ? audio-processor ? CavernPipe handshake succeeds (bit depth != 0).
Ensure rendered PCM flows back to PipeToFifo and into snapcast-out.
Ensure snapserver reads snapcast-out (no EOF) and snapclient can play.
End-to-end flow (what we are trying to do)
Source file: ~/Downloads/demo.mkv (contains multiple audio streams: TrueHD, AC3, E-AC-3).
Streamer: ffmpeg extracts the encoded E-AC-3 elementary bitstream and writes it into FIFO dolby-in. This must be continuous (looped) so Cavern doesn?t see EOF.
On the Pi we ran: ffmpeg -re -stream_loop -1 -i ~/Downloads/demo.mkv -map 0:a:2 -c copy -f data - | dd of=/tmp/dolby-in
FIFO input: dolby-in is read by PipeInputClient which writes the raw container/bitstream into the audio-processor input named pipe cavern-audio-input. (binary bridge)
Audio processor (process in repo audio-processor):
Accepts clients on two named pipes: cavern-audio-input (in) and cavern-audio-output (out). See Program.cs.
Creates an AudioConverter that connects to the CavernPipe named pipe ("CavernPipe") and performs an 8?byte handshake, then sends bitstream frames to CavernPipe.
Reads rendered PCM responses from CavernPipe and writes them to the cavern-audio-output pipe.
File edited: AudioConverter.cs (we patched handshake byte 0 ? 16).
CavernPipe server (CavernPipeServer.Multiplatform) listens on the named pipe "CavernPipe", receives the 8?byte handshake and bitstream, renders using Cavern engine, and sends back interlaced PCM frames.
Server protocol implementation is in CavernPipeProtocol.cs.
PipeToFifo reads cavern-audio-output and writes interlaced PCM into FIFO snapcast-out.
Snapserver reads snapcast-out, encodes/streams it over TCP so snapclient can connect and play.
Where data lives (files / pipes)
Encoded source: ~/Downloads/demo.mkv (on the Pi).
Input FIFO: dolby-in (written by ffmpeg/dd; read by PipeInputClient).
Intermediate named pipes (audio-processor):
Input pipe: cavern-audio-input
Output pipe: cavern-audio-output
Cavern IPC pipe: CavernPipe (named pipe used by CavernPipe server).
Rendered PCM FIFO: snapcast-out (written by PipeToFifo; read by snapserver).
Logs: /tmp/cavern_logs/*.log (audio_processor.log, cavern_pipe.log, pipe_input.log, pipe_output.log, snapserver_out.log, streamer.log).
Protocol / handshake (important)
CavernPipe handshake (8 bytes) before streaming:
Byte 0: Bit depth (in bits per sample). Must be a valid value (8, 16, 24, 32). Server rejects 0.
Byte 1: Mandatory frames to process (server will ensure at least that many frames are included in replies).
Bytes 2-3: Output channel count (UInt16 little-endian).
Bytes 4-7: Update rate (Int32 little-endian) ? samples per channel per frame.
We found the server crashed because byte 0 was 0. We updated AudioConverter to send 16 (Int16) which matches Snapserver?s expectation 48000:16:2.
Key failure modes (what to watch and why)
No writer to dolby-in ? CavernPipe sees EOF / no rendering. Snapserver shows "Exception: end of file". Fix: start ffmpeg loop into FIFO.
Handshake bit-depth = 0 ? server computes zero-size buffers and errors ?The selected bit depth (0) is not supported.? Fix: set handshake[0] to valid bit depth (we set 16).
Broken pipe between PipeInputClient and audio-processor ? PipeInputClient logs ?Broken pipe? and exits. Usually happens if audio-processor exits early (e.g., due to handshake failure).
Multiple snapserver instances bound to same ports ? bind errors. Resolve by stopping system snapserver before starting pipeline snapserver, or run only a single snapserver instance.